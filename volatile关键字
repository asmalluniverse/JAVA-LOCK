volatile关键字：
1.线程可见性问题

我们先从下面的demo来初步了解下可见性问题：

```java
public class VoliatateTrain {

    public static boolean stop = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(()->{
            int i = 0;
            while (!stop){
                i++;
            }
        }).start();

        System.out.println("begin start thread");

        Thread.sleep(1000);
        stop = true;
    }
}
```

运行上面的代码我们可以看出程序是永远不会结束的，上面代码就是可见性的很好的一个体现
main线程对stop的值进行修改而thread线程并不知道。
这里面我们就可以使用volatile关键字进行修改stop，其实这里是jvm 底层进行了深度优化（活性失败）。
其实上面的代码还可以有其它方式进行停止进程：
```java
while (!stop){
                i++;
                //System.out.println(i);
                Thread.sleep(0);
            }
```
其实只要的while 中打印或者睡眠就可以。因为sleep 操作会让cpu进行切换这样就可以得到新的值，而打印语句涉及到了io操作，以及底层
使用的锁，这种方式也是可以的



1.了解可见性问题的本质 
我们先从cpu 层面去思考该问题，为了更好的加快计算机的执行速度，cpu的高速发展，内存以及磁盘的性能提升或者增加核心数等。
都是为了更好的提升计算机性能.
 
（1）cpu资源利用

      cpu    <======>  内存    <========> 磁盘 	  

从硬件层面去考虑，这里不可避免会出现的问题就是，cpu 和内存以及磁盘之间的交互，cpu的计算性能远远大于于他们之间的交互，例如上面列举的
例子，cpu在运行stop指令的时候，需要从内存中读取stop的值，而cpu 的处理速度远远大于和内存的交互以及磁盘io的速度，那么cpu在等待
从内存中加载的数据亦或者从磁盘中读取的数据，在这一个等待的过程中cpu是一个阻塞的状态，这样就会造成cpu 资源浪费，利用不充分。

这样肯定是不合理的所以底层进行了优化：
	1.cpu层面增加了高速缓存（缓存一致性的问题）
	2.编译器层面，jvm底层进行了深度优化JIT,但是会出现上面的问题活性失败。
	3.从操作系统层面，增加了进程和线程来进行处理 --> 通过cpu的时间片切换，提高cpu 的利用率。

cpu层面的高速缓存：
cpu是存在三级缓存了l1,l2,l3，如果cpu进行数据加载的时候会从缓存中读取，如果缓存中没有，那么会从内存中进行加载,
那么加入了缓存的概念，cpu读取数据的方式也进行了改变。引入了缓存肯就就会存在缓存一致性的问题，那么cpu 是如何解决的呢？

我们先从下面图形中了解处理器于内存中数据如何进行交互的：


处理器1   <=====>    高速缓存   <=====>		缓存		主
处理器2   <=====>    高速缓存   <=====>		一致		内
处理器3   <=====>    高速缓存   <=====>		性协议		存

如果处理器1从缓存中读取到了stop 的值，并进行了修改，但是并没有同步到主内存中，而处理2读取缓存中的值还是未修改的值，就会出现上面的问题。
这样应该很好理解，也就是为什么会出现可见性的问题，就是因为cpu 高速缓存的引入，导致了缓存一致性问题的存在。
那如何去解决缓存一致性问题呢？

其实我们不用去认为这是cpu层面的问题，我们可以类比成如果我们程序中出现了上述为题该如何解决呢？？
很容易想到的方式，加锁，那如何控制锁的力度呢，第一在整个程序中加上，只能有一个线程去访问，这种方式对标计算机层面就是加**总线锁**
还有一种方式就是对缓存加锁，减少锁的粒度，提高执行效率，这种方式对标计算机层面就是**缓存一致性协议**。
在多处理器的系统中，提出了很多协议进行处理，需要各个处理器访问缓存时都准守的一些协议，例如MSI  MESI（主流）  MOSI等。

MESI 表示缓存的四种概念：
M
E
S
I

那底层是如何加锁的呢，是通过LOCk汇编指令进行加锁。 


从这个问题其实我们也可以看出，很多问题的解决思路都是共通的，我们不仅要知其然还要知其所以然，不仅仅是解决问题，还是要学习这种思想，
例如我们上面提出的计算机中处理器，高速缓存和主内存之间的交互模型，在java虚拟机中也提出了一种模型jmm也是为了解决类似的问题。
所以说很多思想都是共通的。



延伸：缓存行的问题，对其填充解决伪共享。  缓存行的大小为64字节，java8中也提供了@Contended注解可以实现对其填充。同时需要加入jvm参数才能生效


2.CPU层面的指令重排序
cpu层面是如何导致指令重排序的？
cpu中引入了storybuffer的概念，当保存数据的时候会先把数据保存到storybuffer/storyforwarding中然后继续执行下面的操作，相当于是一个异步的执行过程，
最后在同步到内存中，这样就可能会造成指令重排序的问题

invalid queue


cpu 提供内存屏障 来解决指令重排序的问题，通过LOCK指令实现

出现上述问题的本质就是不断想压榨cpu 的性能，(cpu性能优化的博弈之路)
先是引入了缓存的改变  ---->   导致了缓存一致性的问题   --->加锁来解决
但是加锁会出现阻塞   -----》 有引入了storybuffer/storyforwarding 来进行异步操作  ----》 有可能导致指令重排序，指令之间的执行不会相互等待，是一个异步的过程
-----》为了解决指令重排序带来的可见性问题   ----》 提供了内存屏障进行解决  写屏障  读屏障  全屏障 


volatile 解决多线程环境下的可见性和指令重排序，就是通过lock 指令来实现，lock指令实现了缓存锁/总线锁 提供了内存屏障

	
