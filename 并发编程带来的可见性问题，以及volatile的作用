## 1.什么是线程可见性
在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那
这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程
环境下，读和写发生在不同的线程中的时候，可能会出现：读线程不能及时的读取到其他线程写入的最
新的值，这就是所谓的可见性。

## 2.通过一个案例分析可见性问题
```java
public class VolatileDemo {
public static boolean stop=false;
public static void main(String[] args) throws InterruptedException {
Thread t1=new Thread(()->{
int i=0;
while(!stop){
i++;
}
});
t1.start();
System.out.println("begin start thread");
Thread.sleep(1000);
stop=true;
}
}

```
1. 上面的demo会发生一个什么样的情况呢？ 答案是线程不会终止，一直运行下去，这又是什么原因导致的呢？ 如何去解决呢 ？
**需要注意，这段代码只能在Java Server版本中实现**
2. 问题分析：这里的问题书面语叫：活性失败，这是在HostSpot Server 虚拟机里面，深度优化之后的一种结果，上
述执行结果等价于下面的代码

```java
i
f(!stop){
while(true){
i++;
}
}
```
所以造成上述问题的根本原因是stop这个变量没有通过volatile修饰，而且在主线程睡眠的1000ms中，
while循环中的stop一直处于false状态，当循环到一定的次数之后，会触发JVM的即时编译功能，导致
循环表达式外提从而导致死循环。如果加了volatile，会保证stop这个变量的可见性，从而避免JIT的优
化。
这个深度优化是即时编译器(Just In Time,JIT)帮我们做的，我们可以通过增加一下JVM参数来禁止JIT的
优化的。

-Djava.compiler=NONE 

3.解决办法
	(1)加上volatile关键值
		volatile可以解决可见性问题
	(2)在循环中睡眠
		在这段代码中，我们增加Thread.sleep(0)也能生效，这个我认为是和cpu、以及jvm、操作系统等因素
		有关系。
		官方文档上是说，Thread.sleep没有任何同步语义，编译器不需要在调用Thread.sleep之前把缓存在寄
		存器中的写刷新到给共享内存、也不需要在Thread.sleep之后重新加载缓存在寄存器中的值。
		编译器可以自由选择读取stop的值一次或者多次，这个是由编译器自己来决定的。
			(3)在循环中加上打印语句
		println底层用到了synchronized这个同步关键字，这个同步会防止循环期间对于stop值的缓存。
		因为println有加锁的操作，而释放锁的操作，会强制性的把工作内存中涉及到的写操作同步到主
		内存。
		
**小节**：以上通过一个简单的dmeo引入了可见性的问题，并分析其存在的原因，从jvm层面出发可以看出是jvm进行的深度优化导致的。
这其实只是一个方面，如何真的要了解清楚可见性的问题，我们必须从硬件层面以及操作系统的优化进行分析。


## 3.了解可见性的本质
从如下三个层面进行分析
	1.cpu层面增加了高速缓存（缓存一致性的问题）  （cpu的高速发展史，之cpu的博弈之路）
	2.编译器层面，jvm底层进行了深度优化JIT,但是会出现上面的问题活性失败。 （上面已经分析过，这里不再赘述）
	3.从操作系统层面，增加了进程和线程来进行处理 --> 通过cpu的时间片切换，提高cpu 的利用率。
	
在整个计算机的发展历程中，除了CPU、内存以及I/O设备不断迭代升级来提升计算机处理性能之外，
还有一个非常核心的矛盾点，就是这三者在处理速度的差异。CPU的计算速度是非常快的，其次是内
存、最后是IO设备（比如磁盘），也就是CPU的计算速度远远高于内存以及磁盘设备的I/O速度。
如下图所示，计算机是利用CPU进行数据运算的，但是CPU只能对内存中的数据进行运算，对于磁盘中
的数据，必须要先读取到内存，CPU才能进行运算，也就是CPU和内存之间无法避免的出现了IO操作。
而cpu的运算速度远远高于内存的IO速度，比如在一台2.4GHz的cpu上，每秒能处理2.4x10的9次方，每次
处理的数据量，如果是64位操作系统，那么意味着每次能处理64位数据量。

虽然CPU从单核升级到多核甚至到超线程技术在最大化的提高CPU的处理性能，但是仅仅提升CPU性能
是不够的，如果内存和磁盘的处理性能没有跟上，就意味着整体的计算效率取决于最慢的设备，为了平
衡这三者之间的速度差异，最大化的利用CPU。所以在硬件层面、操作系统层面、编译器层面做出了很
多的优化
1. CPU增加了高速缓存
2. 操作系统增加了进程、线程。通过CPU的时间片切换最大化的提升CPU的使用率
3. 编译器的指令优化，更合理的去利用好CPU的高速缓存

##### 1.CPU为了提高效率，引入了缓存和多线程
CPU在做计算时，和内存的IO操作是无法避免的，而这个IO过程相对于CPU的计算速度来说是非常耗
时，基于这样一个问题，所以在CPU层面设计了高速缓存，这个缓存行可以缓存存储在内存中的数据，
CPU每次会先从缓存行中读取需要运算的数据，如果缓存行中不存在该数据，才会从内存中加载，通过
这样一个机制可以减少CPU和内存的交互开销从而提升CPU的利用率。
对于主流的x86平台，cpu的缓存行（cache）分为L1、L2、L3总共3级。

并且有了多线程充分利用cpu资源。

##### 2.引入了缓存，必然会导致缓存一致性问题
CPU高速缓存的出现，虽然提升了CPU的利用率，但是同时也带来了另外一个问题--缓存一致性问题，
这个一致性问题体现在。
在多线程环境中，当多个线程并行执行加载同一块内存数据时，由于每个CPU都有自己独立的L1、L2缓
存，所以每个CPU的这部分缓存空间都会缓存到相同的数据，并且每个CPU执行相关指令时，彼此之间
不可见，就会导致缓存的一致性问题，据图流程如下图所示：

##### 3.如何解决缓存一致性问题呢？ 
1. 使用总线锁：某个核心在修改数据的过程中，其他核心均无法修改内存中的数据（类似于独占内存的概念，
	只要有cpu在修改，那别的cpu就等待当前cpu释放）
2. 缓存一致性协议
	为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常
	见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来给大家简单讲解一下MESI。
	MESI表示缓存行的四种状态，分别是
	1. M(Modify[修改状态]) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的
	数据和主内存中的数据不一致\
	2. E(Exclusive[独占状态]) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改
	3. S(Shared[共享状态]) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致
	4. I(Invalid[无效状态]) 表示缓存已经失效
	在CPU的缓存行中，每一个Cache一定会处于以下三种状态之一
	Shared
	Exclusive
	Invalid
	
	**缓存一致性协议可以理解为，对缓存行加锁。**

##### 4.为了解决有序性和可见性问题，引入内存屏障的概念
CPU在性能优化道路上导致的顺序一致性问题，在CPU层面无法被解决，原因是CPU只是一个运算工
具，它只接收指令并且执行指令，并不清楚当前执行的整个逻辑中是否存在不能优化的问题，也就是说
硬件层面也无法优化这种顺序一致性带来的可见性问题。
因此，在CPU层面提供了写屏障、读屏障、全屏障这样的指令，内存屏障其实就是为了解决异步优化导致
的cpu乱序执行（缓存不及时可见）的问题，直接把异步优化给禁用。

在x86架构中，这三种指令分别是
SFENCE、LFENCE、MFENCE指令，
sfence：也就是save fence，写屏障指令。在sfence指令前的写操作必须在sfence指令后的写操作
前完成。
lfence：也就是load fence，读屏障指令。在lfence指令前的读操作必须在lfence指令后的读操作
前完成。
mfence：也就是modify/mix，混合屏障指令，在mfence前得读写操作必须在mfence指令后的读
写操作前完成。
在Linux系统中，将这三种指令分别封装成了, smp_wmb-写屏障 、 smp_rmb-读屏障 、 smp_mb-读写屏障 三
个方法

屏障可以理解为：在操作数据的时候，往数据插入一条特殊的指令，只要需要这条指令，那前面的操作都要完成。
写屏障可以理解为cpu当发现写屏障的指令时，会把该执行之前存在于store Buffer所有写指令刷新到高速缓存中。
读屏障可以理解为，cpu当发现读屏障指令时，会把该指令之前存在于invalid queue 无效队列中的所有指令都处理掉。


##### 5.引入java内存模型的概念
上面说了半天还一直处于硬件/操作系统层面的优化（cpu的高速发展之路带来的问题，以及如何解决；多线程存在的问题，以及如何解决  这两个层面进行的分析）

由于不同的cpu架构的缓存体系不一样，缓存一致性协议不一样，重排序的策略不一样，所以提供的内存屏障指令也有差异，
为了简化java开发人员的工作，java分装了一套规范，这套规范就是java内存模型。

java内存模型存在的意义就在于屏蔽各种硬件和操作系统的差异，保证java程序达到一次编译到处运行的效果。
目的就是为了解决原子性、可见性以及有序性的问题。



单线程的环境下是不会存在可见性、有序性、和原子性问题，因为无并发的存在，并且编译器准守着as-if-serial语义
