# cas

1. cas 全称：compare and swap 比较并替换，他是一个原子操作，对应的cpu指令是cmpxchg.

主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：
	变量内存地址，V表示
	旧的预期值，A表示
	准备设置的新值，B表示
2. 什么是cas操作

   1. 当前值A，内存值V，要修改的新值B。
   2. 只要当前值A跟内存值V相等，那就将内存值修改成新值B。要么成功要么失败。

3. 为什么要使用cas（优点）

   对比于synchrinozed锁，每次都是让一个线程去操作共享资源，这个一个悲观锁，而cas是一个乐观锁，相当于没有加锁，多个线程可以直接操作共享资源，而实际去修改的时候采取判断是否能修改成功，在大多数情况下，锁竞争并没有那么频繁，可能加锁和释放锁的时间都要大于业务操作的事件，造成了频繁的上下文切换，印象性能，所以使用cas可以避免频繁的上下文切换。

4. cas的缺点

   1. ABA的问题：假设线程A读取到的当前值的10，可能线程B把值修改为100，然后线程C又把值修改为10，等到线程A拿到执行权时，因为当前的值和内存值一致，还是可以修改成功。

      如何解决ABA的问题：JAVA提供了AtomicStampedReference类，本质就是加了一个版本进行控制，对比内存值和版本是否一致。

   2. 自旋消耗资源，因为多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。

      解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。

      虽然base和cells都是volatile修饰的，但感觉这个sum操作没有加锁，可能sum的结果不是那么精确。

   3. 多变量共享一致性问题：

      解决方法： CAS操作是针对一个变量的，如果对多个变量操作，

      1) 可以加锁来解决。

      2) 封装成对象类解决。